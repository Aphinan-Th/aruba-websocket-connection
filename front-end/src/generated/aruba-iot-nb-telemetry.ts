/* eslint-disable no-case-declarations */
// @generated by protobuf-ts 2.9.3 with parameter long_type_string
// @generated from protobuf file "aruba-iot-nb-telemetry.proto" (package "aruba_telemetry", syntax proto2)
// tslint:disable
//
//  (C) Copyright [2018-2022] Hewlett Packard Enterprise Development LP
//  Note: File corresponds to AOS 8.10.x.x release
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { deviceClassEnum } from "./aruba-iot-types";
/**
 * Device firmware info. as decoded by AOS
 *
 * @generated from protobuf message aruba_telemetry.Firmware
 */
export interface Firmware {
    /**
     * Active Firmware version
     *
     * @generated from protobuf field: optional string version = 1;
     */
    version?: string;
    /**
     * Firmware version reporting format for specific devices
     *
     * @generated from protobuf field: optional string bankA = 2;
     */
    bankA?: string;
    /**
     * Firmware version reporting format for specific devices
     *
     * @generated from protobuf field: optional string bankB = 3;
     */
    bankB?: string;
}
/**
 * RSSI history information
 *
 * @generated from protobuf message aruba_telemetry.History
 */
export interface History {
    /**
     * time of reading
     *
     * @generated from protobuf field: uint64 time = 1;
     */
    time: string;
    /**
     * RSSI value in dBm
     *
     * @generated from protobuf field: sint32 rssi = 2;
     */
    rssi: number;
    /**
     * radio id from where RSSI was received
     *
     * @generated from protobuf field: optional int32 rxRadioId = 3;
     */
    rxRadioId?: number;
    /**
     * Antenna value from where RSSI was recorded
     *
     * @generated from protobuf field: optional int32 antenna = 4;
     */
    antenna?: number;
}
/**
 * RSSI information for BLE device as configured in the
 * transport profile over the most recent reporting interval
 *
 * @generated from protobuf message aruba_telemetry.Rssi
 */
export interface Rssi {
    /**
     * last (most recent) RSSI reading in a reporting interval
     *
     * @generated from protobuf field: optional sint32 last = 1;
     */
    last?: number;
    /**
     * average/mean RSSI reading over reporting interval
     *
     * @generated from protobuf field: optional sint32 avg = 2;
     */
    avg?: number;
    /**
     * maximum RSSI reading over reporting interval
     *
     * @generated from protobuf field: optional sint32 max = 3;
     */
    max?: number;
    /**
     * report multiple RSSI readings over reporting interval
     *
     * @generated from protobuf field: repeated aruba_telemetry.History history = 4;
     */
    history: History[];
    /**
     * Smooth the RSSI values using built-in smoothing function
     *
     * @generated from protobuf field: optional sint32 smooth = 5;
     */
    smooth?: number;
}
/**
 * Indicates device status when the cell size filter is set
 * in the IoT transport profile
 *
 * @generated from protobuf message aruba_telemetry.BeaconEvent
 */
export interface BeaconEvent {
    /**
     * @generated from protobuf field: optional aruba_telemetry.CellEvent event = 1;
     */
    event?: CellEvent;
}
/**
 * Indicates device status when the cell size filter is set
 * in the IoT transport profile
 *
 * @generated from protobuf message aruba_telemetry.Cell
 */
export interface Cell {
    /**
     * @generated from protobuf field: optional bool isInside = 1;
     */
    isInside?: boolean;
    /**
     * @generated from protobuf field: optional float distance = 2;
     */
    distance?: number;
}
/**
 * IBeacon params. from device's advertisement data
 *
 * @generated from protobuf message aruba_telemetry.Ibeacon
 */
export interface Ibeacon {
    /**
     * @generated from protobuf field: bytes uuid = 1;
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: uint32 major = 2;
     */
    major: number;
    /**
     * @generated from protobuf field: uint32 minor = 3;
     */
    minor: number;
    /**
     * @generated from protobuf field: sint32 power = 4;
     */
    power: number;
    /**
     * @generated from protobuf field: optional bytes extra = 5;
     */
    extra?: Uint8Array;
}
/**
 * Eddystone UID params. from device's advertisement data
 *
 * @generated from protobuf message aruba_telemetry.EddyUID
 */
export interface EddyUID {
    /**
     * @generated from protobuf field: bytes nid = 1;
     */
    nid: Uint8Array;
    /**
     * @generated from protobuf field: bytes bid = 2;
     */
    bid: Uint8Array;
}
/**
 * Eddystone URL params. from device's advertisement data
 *
 * @generated from protobuf message aruba_telemetry.EddyURL
 */
export interface EddyURL {
    /**
     * @generated from protobuf field: uint32 prefix = 1;
     */
    prefix: number;
    /**
     * @generated from protobuf field: bytes encodedUrl = 2;
     */
    encodedUrl: Uint8Array;
}
/**
 * Eddystone txpower and UID/URL params. from device's advertisement data
 *
 * @generated from protobuf message aruba_telemetry.Eddystone
 */
export interface Eddystone {
    /**
     * @generated from protobuf field: optional sint32 power = 1;
     */
    power?: number;
    /**
     * @generated from protobuf field: optional aruba_telemetry.EddyUID uid = 2;
     */
    uid?: EddyUID;
    /**
     * @generated from protobuf field: optional aruba_telemetry.EddyURL url = 3;
     */
    url?: EddyURL;
}
/**
 * @generated from protobuf message aruba_telemetry.Beacons
 */
export interface Beacons {
    /**
     * @generated from protobuf field: optional aruba_telemetry.Ibeacon ibeacon = 1;
     */
    ibeacon?: Ibeacon;
    /**
     * @generated from protobuf field: optional aruba_telemetry.Eddystone eddystone = 2;
     */
    eddystone?: Eddystone; //  reserved                                  3;
}
/**
 * Accelerometer sensor information
 *
 * @generated from protobuf message aruba_telemetry.Accelerometer
 */
export interface Accelerometer {
    /**
     * @generated from protobuf field: float x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: float y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: float z = 3;
     */
    z: number;
    /**
     * @generated from protobuf field: optional aruba_telemetry.AccelStatus status = 4;
     */
    status?: AccelStatus;
}
/**
 * Rocker switch information onboard BLE device
 *
 * @generated from protobuf message aruba_telemetry.RockerSwitch
 */
export interface RockerSwitch {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: aruba_telemetry.rockerSwitchPosition state = 2;
     */
    state: rockerSwitchPosition;
}
/**
 * Contact sensor information
 *
 * @generated from protobuf message aruba_telemetry.Contact
 */
export interface Contact {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number;
    /**
     * @generated from protobuf field: aruba_telemetry.ContactPosition state = 2;
     */
    state: ContactPosition;
}
/**
 * Occupancy sensor information
 *
 * @generated from protobuf message aruba_telemetry.Occupancy
 */
export interface Occupancy {
    /**
     * @generated from protobuf field: optional uint32 level = 1;
     */
    level?: number;
}
/**
 * Sensor values as decoded from BLE packets
 * the units for the sensor values depends upon
 * the underlying sensor/device type.
 *
 * @generated from protobuf message aruba_telemetry.Sensors
 */
export interface Sensors {
    /**
     * @generated from protobuf field: optional aruba_telemetry.Accelerometer accelerometer = 1;
     */
    accelerometer?: Accelerometer;
    /**
     * @generated from protobuf field: optional int32 battery = 2;
     */
    battery?: number;
    /**
     * @generated from protobuf field: optional float temperatureC = 3;
     */
    temperatureC?: number;
    /**
     * @generated from protobuf field: optional int32 humidity = 4;
     */
    humidity?: number;
    /**
     * @generated from protobuf field: optional float voltage = 5;
     */
    voltage?: number;
    /**
     * @generated from protobuf field: optional int32 illumination = 6;
     */
    illumination?: number;
    /**
     * @generated from protobuf field: optional bool motion = 7;
     */
    motion?: boolean;
    /**
     * @generated from protobuf field: optional sint32 current = 8;
     */
    current?: number;
    /**
     * @generated from protobuf field: optional int32 CO = 9 [json_name = "CO"];
     */
    cO?: number;
    /**
     * @generated from protobuf field: optional int32 CO2 = 10 [json_name = "CO2"];
     */
    cO2?: number;
    /**
     * @generated from protobuf field: optional int32 VOC = 11 [json_name = "VOC"];
     */
    vOC?: number;
    /**
     * @generated from protobuf field: optional float resistance = 12;
     */
    resistance?: number;
    /**
     * @generated from protobuf field: optional sint32 pressure = 13;
     */
    pressure?: number;
    /**
     * @generated from protobuf field: repeated aruba_telemetry.Alarm alarm = 14;
     */
    alarm: Alarm[];
    /**
     * @generated from protobuf field: repeated aruba_telemetry.Contact contact = 15;
     */
    contact: Contact[];
    /**
     * @generated from protobuf field: optional aruba_telemetry.Occupancy occupancy = 16;
     */
    occupancy?: Occupancy;
    /**
     * @generated from protobuf field: optional aruba_telemetry.MechanicalH mechanicalHandle = 17;
     */
    mechanicalHandle?: MechanicalH;
    /**
     * @generated from protobuf field: optional int32 distance = 18;
     */
    distance?: number;
    /**
     * @generated from protobuf field: optional float capacitance = 19;
     */
    capacitance?: number;
}
/**
 * Statistics regarding the BLE device
 *
 * @generated from protobuf message aruba_telemetry.Stats
 */
export interface Stats {
    /**
     * device uptime in second
     *
     * @generated from protobuf field: optional uint64 uptime = 1;
     */
    uptime?: string;
    /**
     * number of advertisement packets
     *
     * @generated from protobuf field: optional uint64 adv_cnt = 2;
     */
    advCnt?: string;
    /**
     * sequence number of packet
     *
     * @generated from protobuf field: optional uint32 seq_nr = 3;
     */
    seqNr?: number;
    /**
     * total frame count (advertisements and scan responses)
     * in a given reporting interval
     *
     * @generated from protobuf field: uint32 frame_cnt = 4;
     */
    frameCnt: number;
}
/**
 * Values for different input modalities on BLE devices
 *
 * @generated from protobuf message aruba_telemetry.Inputs
 */
export interface Inputs {
    /**
     * Rocker switch information
     *
     * @generated from protobuf field: repeated aruba_telemetry.RockerSwitch rocker = 1;
     */
    rocker: RockerSwitch[];
    /**
     * Switch state information
     *
     * @generated from protobuf field: repeated aruba_telemetry.switchState switchIndex = 2;
     */
    switchIndex: switchState[];
}
/**
 * Vendor data corresponds to the entity that
 * manufactured the BLE device. This is a fixed mapping for
 * certain vendors in AOS
 *
 * @generated from protobuf message aruba_telemetry.VendorData
 */
export interface VendorData {
    /**
     * @generated from protobuf field: optional string vendor = 1;
     */
    vendor?: string;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
}
/**
 * BT SIG Company ID Information
 *
 * @generated from protobuf message aruba_telemetry.BTCompanyID
 */
export interface BTCompanyID {
    /**
     * number corresponds to 2 byte hex for the company identifier
     *
     * @generated from protobuf field: optional uint32 value = 1;
     */
    value?: number;
    /**
     * company name as specified in the BT SIG identifier list
     *
     * @generated from protobuf field: optional string description = 2;
     */
    description?: string;
}
/**
 * Values contained herein correspond to BLE device information
 * gleaned from advertisement/scan responses that are decoded by
 * the Aruba infrastructure. The periodicity of this message is
 * controlled by the transport profile parameters.
 *
 * @generated from protobuf message aruba_telemetry.Reported
 */
export interface Reported {
    /**
     * BLE MAC address of observed device
     *
     * @generated from protobuf field: optional bytes mac = 1;
     */
    mac?: Uint8Array;
    /**
     * Device class label assigned by AOS infra
     * see aruba-iot-types.proto
     *
     * @generated from protobuf field: repeated aruba_telemetry.deviceClassEnum deviceClass = 2;
     */
    deviceClass: deviceClassEnum[];
    /**
     * Device model number as decoded by AOS
     *
     * @generated from protobuf field: optional string model = 3;
     */
    model?: string;
    /**
     * Device firmware info. as decoded by AOS
     *
     * @generated from protobuf field: optional aruba_telemetry.Firmware firmware = 4;
     */
    firmware?: Firmware;
    /**
     * Device specific id
     *
     * @generated from protobuf field: optional string assetId = 5;
     */
    assetId?: string;
    /**
     * Device public key
     *
     * @generated from protobuf field: optional bytes publicKey = 6;
     */
    publicKey?: Uint8Array;
    /**
     * Timestamp device data was recorded by this AP/APB
     *
     * @generated from protobuf field: optional uint64 lastSeen = 7;
     */
    lastSeen?: string;
    //    reserved                                8;

    /**
     * Indicate device's status w.r.t. cell size
     * as defined in the IoT transport profile
     *
     * @generated from protobuf field: optional aruba_telemetry.BeaconEvent bevent = 9;
     */
    bevent?: BeaconEvent;
    /**
     * Observed RSSI information
     *
     * @generated from protobuf field: optional aruba_telemetry.Rssi rssi = 10;
     */
    rssi?: Rssi;
    /**
     * Indicate device's status w.r.t. cell size
     * as defined in the IoT transport profile
     *
     * @generated from protobuf field: optional aruba_telemetry.Cell cell = 11;
     */
    cell?: Cell;
    /**
     * IBeacon/Eddystone decoded fields
     *
     * @generated from protobuf field: repeated aruba_telemetry.Beacons beacons = 12;
     */
    beacons: Beacons[];
    /**
     * Device Transmit power
     *
     * @generated from protobuf field: optional sint32 txpower = 13;
     */
    txpower?: number;
    /**
     * Sensor values
     *
     * @generated from protobuf field: optional aruba_telemetry.Sensors sensors = 14;
     */
    sensors?: Sensors;
    //    reserved                                15;

    /**
     * BLE device packet statistics
     *
     * @generated from protobuf field: optional aruba_telemetry.Stats stats = 16;
     */
    stats?: Stats;
    /**
     * BLE device that are capable of receiving physical input from user
     *
     * @generated from protobuf field: optional aruba_telemetry.Inputs inputs = 17;
     */
    inputs?: Inputs;
    /**
     * Vendor information for BLE device
     *
     * @generated from protobuf field: optional aruba_telemetry.VendorData vendorData = 18;
     */
    vendorData?: VendorData;
    /**
     * Vendor name string
     *
     * @generated from protobuf field: optional string vendorName = 19;
     */
    vendorName?: string;
    /**
     * Timestamp when sensor values were updated
     *
     * @generated from protobuf field: optional uint64 sensorTimestamp = 20;
     */
    sensorTimestamp?: string;
    /**
     * Any flags values set for the BLE device
     *
     * @generated from protobuf field: optional uint32 flags = 21;
     */
    flags?: number;
    /**
     * Localname string seen in BLE packets
     *
     * @generated from protobuf field: optional string localName = 22;
     */
    localName?: string;
    /**
     * Identity string observed from BLE packets
     *
     * @generated from protobuf field: optional string identity = 23;
     */
    identity?: string;
    /**
     * BT SIG company identifier information
     *
     * @generated from protobuf field: repeated aruba_telemetry.BTCompanyID companyIdentifier = 24;
     */
    companyIdentifier: BTCompanyID[];
}
/**
 * Values for rocker switch position
 *
 * @generated from protobuf enum aruba_telemetry.rockerSwitchPosition
 */
export enum rockerSwitchPosition {
    /**
     * @generated from protobuf enum value: idle = 0;
     */
    idle = 0,
    /**
     * @generated from protobuf enum value: topPressed = 1;
     */
    topPressed = 1,
    /**
     * @generated from protobuf enum value: bottomPressed = 2;
     */
    bottomPressed = 2
}
/**
 * Enum values indicate device's status w.r.t. cell size
 * as defined in the IoT transport profile
 *
 * @generated from protobuf enum aruba_telemetry.CellEvent
 */
export enum CellEvent {
    /**
     * @generated from protobuf enum value: entry = 0;
     */
    entry = 0,
    /**
     * @generated from protobuf enum value: exit = 1;
     */
    exit = 1,
    /**
     * @generated from protobuf enum value: update = 2;
     */
    update = 2,
    /**
     * @generated from protobuf enum value: ageout = 3;
     */
    ageout = 3
}
/**
 * Values for accelerometer status
 *
 * @generated from protobuf enum aruba_telemetry.AccelStatus
 */
export enum AccelStatus {
    /**
     * @generated from protobuf enum value: ok = 0;
     */
    ok = 0,
    /**
     * @generated from protobuf enum value: outOfRange = 1;
     */
    outOfRange = 1,
    /**
     * @generated from protobuf enum value: threshold1 = 2;
     */
    threshold1 = 2,
    /**
     * @generated from protobuf enum value: threshold2 = 3;
     */
    threshold2 = 3
}
/**
 * Values for type of alarm sensor onboard BLE device
 *
 * @generated from protobuf enum aruba_telemetry.Alarm
 */
export enum Alarm {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: water = 1;
     */
    water = 1,
    /**
     * @generated from protobuf enum value: smoke = 2;
     */
    smoke = 2,
    /**
     * @generated from protobuf enum value: fire = 3;
     */
    fire = 3,
    /**
     * @generated from protobuf enum value: glassbreak = 4;
     */
    glassbreak = 4,
    /**
     * @generated from protobuf enum value: intrusion = 5;
     */
    intrusion = 5
}
/**
 * Values for contact sensor onboard BLE device
 *
 * @generated from protobuf enum aruba_telemetry.ContactPosition
 */
export enum ContactPosition {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: open = 1;
     */
    open = 1,
    /**
     * @generated from protobuf enum value: closed = 2;
     */
    closed = 2
}
/**
 * Values for mechanical handle sensor onboard BLE device
 *
 * @generated from protobuf enum aruba_telemetry.MechanicalH
 */
export enum MechanicalH {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: upToRight = 1;
     */
    upToRight = 1,
    /**
     * @generated from protobuf enum value: rightToDown = 2;
     */
    rightToDown = 2,
    /**
     * @generated from protobuf enum value: downToLeft = 3;
     */
    downToLeft = 3,
    /**
     * @generated from protobuf enum value: leftToUp = 4;
     */
    leftToUp = 4,
    /**
     * @generated from protobuf enum value: upToLeft = 5;
     */
    upToLeft = 5,
    /**
     * @generated from protobuf enum value: leftToDown = 6;
     */
    leftToDown = 6,
    /**
     * @generated from protobuf enum value: downToRight = 7;
     */
    downToRight = 7,
    /**
     * @generated from protobuf enum value: rightToUp = 8;
     */
    rightToUp = 8
}
/**
 * Values communicate the state of the switch sensor
 * onboard the BLE device
 *
 * @generated from protobuf enum aruba_telemetry.switchState
 */
export enum switchState {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: unknown = 1;
     */
    unknown = 1,
    /**
     * @generated from protobuf enum value: on = 2;
     */
    on = 2,
    /**
     * @generated from protobuf enum value: off = 3;
     */
    off = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Firmware$Type extends MessageType<Firmware> {
    constructor() {
        super("aruba_telemetry.Firmware", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bankA", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bankB", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Firmware>): Firmware {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Firmware>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Firmware): Firmware {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string version */ 1:
                    message.version = reader.string();
                    break;
                case /* optional string bankA */ 2:
                    message.bankA = reader.string();
                    break;
                case /* optional string bankB */ 3:
                    message.bankB = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Firmware, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string version = 1; */
        if (message.version !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* optional string bankA = 2; */
        if (message.bankA !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.bankA);
        /* optional string bankB = 3; */
        if (message.bankB !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.bankB);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Firmware
 */
export const Firmware = new Firmware$Type();
// @generated message type with reflection information, may provide speed optimized methods
class History$Type extends MessageType<History> {
    constructor() {
        super("aruba_telemetry.History", [
            { no: 1, name: "time", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "rssi", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "rxRadioId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "antenna", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<History>): History {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.time = "0";
        message.rssi = 0;
        if (value !== undefined)
            reflectionMergePartial<History>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: History): History {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time */ 1:
                    message.time = reader.uint64().toString();
                    break;
                case /* sint32 rssi */ 2:
                    message.rssi = reader.sint32();
                    break;
                case /* optional int32 rxRadioId */ 3:
                    message.rxRadioId = reader.int32();
                    break;
                case /* optional int32 antenna */ 4:
                    message.antenna = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: History, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time = 1; */
        if (message.time !== "0")
            writer.tag(1, WireType.Varint).uint64(message.time);
        /* sint32 rssi = 2; */
        if (message.rssi !== 0)
            writer.tag(2, WireType.Varint).sint32(message.rssi);
        /* optional int32 rxRadioId = 3; */
        if (message.rxRadioId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.rxRadioId);
        /* optional int32 antenna = 4; */
        if (message.antenna !== undefined)
            writer.tag(4, WireType.Varint).int32(message.antenna);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.History
 */
export const History = new History$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rssi$Type extends MessageType<Rssi> {
    constructor() {
        super("aruba_telemetry.Rssi", [
            { no: 1, name: "last", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "avg", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "max", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "history", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => History },
            { no: 5, name: "smooth", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Rssi>): Rssi {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.history = [];
        if (value !== undefined)
            reflectionMergePartial<Rssi>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rssi): Rssi {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 last */ 1:
                    message.last = reader.sint32();
                    break;
                case /* optional sint32 avg */ 2:
                    message.avg = reader.sint32();
                    break;
                case /* optional sint32 max */ 3:
                    message.max = reader.sint32();
                    break;
                case /* repeated aruba_telemetry.History history */ 4:
                    message.history.push(History.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional sint32 smooth */ 5:
                    message.smooth = reader.sint32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rssi, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 last = 1; */
        if (message.last !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.last);
        /* optional sint32 avg = 2; */
        if (message.avg !== undefined)
            writer.tag(2, WireType.Varint).sint32(message.avg);
        /* optional sint32 max = 3; */
        if (message.max !== undefined)
            writer.tag(3, WireType.Varint).sint32(message.max);
        /* repeated aruba_telemetry.History history = 4; */
        for (let i = 0; i < message.history.length; i++)
            History.internalBinaryWrite(message.history[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional sint32 smooth = 5; */
        if (message.smooth !== undefined)
            writer.tag(5, WireType.Varint).sint32(message.smooth);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Rssi
 */
export const Rssi = new Rssi$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeaconEvent$Type extends MessageType<BeaconEvent> {
    constructor() {
        super("aruba_telemetry.BeaconEvent", [
            { no: 1, name: "event", kind: "enum", opt: true, T: () => ["aruba_telemetry.CellEvent", CellEvent] }
        ]);
    }
    create(value?: PartialMessage<BeaconEvent>): BeaconEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BeaconEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeaconEvent): BeaconEvent {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional aruba_telemetry.CellEvent event */ 1:
                    message.event = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeaconEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional aruba_telemetry.CellEvent event = 1; */
        if (message.event !== undefined)
            writer.tag(1, WireType.Varint).int32(message.event);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.BeaconEvent
 */
export const BeaconEvent = new BeaconEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cell$Type extends MessageType<Cell> {
    constructor() {
        super("aruba_telemetry.Cell", [
            { no: 1, name: "isInside", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "distance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Cell>): Cell {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Cell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cell): Cell {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool isInside */ 1:
                    message.isInside = reader.bool();
                    break;
                case /* optional float distance */ 2:
                    message.distance = reader.float();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool isInside = 1; */
        if (message.isInside !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isInside);
        /* optional float distance = 2; */
        if (message.distance !== undefined)
            writer.tag(2, WireType.Bit32).float(message.distance);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Cell
 */
export const Cell = new Cell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ibeacon$Type extends MessageType<Ibeacon> {
    constructor() {
        super("aruba_telemetry.Ibeacon", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "power", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 5, name: "extra", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Ibeacon>): Ibeacon {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        message.major = 0;
        message.minor = 0;
        message.power = 0;
        if (value !== undefined)
            reflectionMergePartial<Ibeacon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ibeacon): Ibeacon {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                case /* uint32 major */ 2:
                    message.major = reader.uint32();
                    break;
                case /* uint32 minor */ 3:
                    message.minor = reader.uint32();
                    break;
                case /* sint32 power */ 4:
                    message.power = reader.sint32();
                    break;
                case /* optional bytes extra */ 5:
                    message.extra = reader.bytes();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ibeacon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        /* uint32 major = 2; */
        if (message.major !== 0)
            writer.tag(2, WireType.Varint).uint32(message.major);
        /* uint32 minor = 3; */
        if (message.minor !== 0)
            writer.tag(3, WireType.Varint).uint32(message.minor);
        /* sint32 power = 4; */
        if (message.power !== 0)
            writer.tag(4, WireType.Varint).sint32(message.power);
        /* optional bytes extra = 5; */
        if (message.extra !== undefined)
            writer.tag(5, WireType.LengthDelimited).bytes(message.extra);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Ibeacon
 */
export const Ibeacon = new Ibeacon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EddyUID$Type extends MessageType<EddyUID> {
    constructor() {
        super("aruba_telemetry.EddyUID", [
            { no: 1, name: "nid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "bid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<EddyUID>): EddyUID {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nid = new Uint8Array(0);
        message.bid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<EddyUID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EddyUID): EddyUID {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes nid */ 1:
                    message.nid = reader.bytes();
                    break;
                case /* bytes bid */ 2:
                    message.bid = reader.bytes();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EddyUID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes nid = 1; */
        if (message.nid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nid);
        /* bytes bid = 2; */
        if (message.bid.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.bid);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.EddyUID
 */
export const EddyUID = new EddyUID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EddyURL$Type extends MessageType<EddyURL> {
    constructor() {
        super("aruba_telemetry.EddyURL", [
            { no: 1, name: "prefix", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "encodedUrl", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<EddyURL>): EddyURL {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prefix = 0;
        message.encodedUrl = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<EddyURL>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EddyURL): EddyURL {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 prefix */ 1:
                    message.prefix = reader.uint32();
                    break;
                case /* bytes encodedUrl */ 2:
                    message.encodedUrl = reader.bytes();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EddyURL, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 prefix = 1; */
        if (message.prefix !== 0)
            writer.tag(1, WireType.Varint).uint32(message.prefix);
        /* bytes encodedUrl = 2; */
        if (message.encodedUrl.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.encodedUrl);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.EddyURL
 */
export const EddyURL = new EddyURL$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Eddystone$Type extends MessageType<Eddystone> {
    constructor() {
        super("aruba_telemetry.Eddystone", [
            { no: 1, name: "power", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "uid", kind: "message", T: () => EddyUID },
            { no: 3, name: "url", kind: "message", T: () => EddyURL }
        ]);
    }
    create(value?: PartialMessage<Eddystone>): Eddystone {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Eddystone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Eddystone): Eddystone {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional sint32 power */ 1:
                    message.power = reader.sint32();
                    break;
                case /* optional aruba_telemetry.EddyUID uid */ 2:
                    message.uid = EddyUID.internalBinaryRead(reader, reader.uint32(), options, message.uid);
                    break;
                case /* optional aruba_telemetry.EddyURL url */ 3:
                    message.url = EddyURL.internalBinaryRead(reader, reader.uint32(), options, message.url);
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Eddystone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional sint32 power = 1; */
        if (message.power !== undefined)
            writer.tag(1, WireType.Varint).sint32(message.power);
        /* optional aruba_telemetry.EddyUID uid = 2; */
        if (message.uid)
            EddyUID.internalBinaryWrite(message.uid, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.EddyURL url = 3; */
        if (message.url)
            EddyURL.internalBinaryWrite(message.url, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Eddystone
 */
export const Eddystone = new Eddystone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Beacons$Type extends MessageType<Beacons> {
    constructor() {
        super("aruba_telemetry.Beacons", [
            { no: 1, name: "ibeacon", kind: "message", T: () => Ibeacon },
            { no: 2, name: "eddystone", kind: "message", T: () => Eddystone }
        ]);
    }
    create(value?: PartialMessage<Beacons>): Beacons {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Beacons>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Beacons): Beacons {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional aruba_telemetry.Ibeacon ibeacon */ 1:
                    message.ibeacon = Ibeacon.internalBinaryRead(reader, reader.uint32(), options, message.ibeacon);
                    break;
                case /* optional aruba_telemetry.Eddystone eddystone */ 2:
                    message.eddystone = Eddystone.internalBinaryRead(reader, reader.uint32(), options, message.eddystone);
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Beacons, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional aruba_telemetry.Ibeacon ibeacon = 1; */
        if (message.ibeacon)
            Ibeacon.internalBinaryWrite(message.ibeacon, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.Eddystone eddystone = 2; */
        if (message.eddystone)
            Eddystone.internalBinaryWrite(message.eddystone, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Beacons
 */
export const Beacons = new Beacons$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Accelerometer$Type extends MessageType<Accelerometer> {
    constructor() {
        super("aruba_telemetry.Accelerometer", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "status", kind: "enum", opt: true, T: () => ["aruba_telemetry.AccelStatus", AccelStatus] }
        ]);
    }
    create(value?: PartialMessage<Accelerometer>): Accelerometer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Accelerometer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Accelerometer): Accelerometer {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                case /* float z */ 3:
                    message.z = reader.float();
                    break;
                case /* optional aruba_telemetry.AccelStatus status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Accelerometer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit32).float(message.y);
        /* float z = 3; */
        if (message.z !== 0)
            writer.tag(3, WireType.Bit32).float(message.z);
        /* optional aruba_telemetry.AccelStatus status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Accelerometer
 */
export const Accelerometer = new Accelerometer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RockerSwitch$Type extends MessageType<RockerSwitch> {
    constructor() {
        super("aruba_telemetry.RockerSwitch", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["aruba_telemetry.rockerSwitchPosition", rockerSwitchPosition] }
        ]);
    }
    create(value?: PartialMessage<RockerSwitch>): RockerSwitch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<RockerSwitch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RockerSwitch): RockerSwitch {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* aruba_telemetry.rockerSwitchPosition state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RockerSwitch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* aruba_telemetry.rockerSwitchPosition state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.RockerSwitch
 */
export const RockerSwitch = new RockerSwitch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contact$Type extends MessageType<Contact> {
    constructor() {
        super("aruba_telemetry.Contact", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "enum", T: () => ["aruba_telemetry.ContactPosition", ContactPosition] }
        ]);
    }
    create(value?: PartialMessage<Contact>): Contact {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<Contact>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contact): Contact {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* aruba_telemetry.ContactPosition state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contact, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* aruba_telemetry.ContactPosition state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Contact
 */
export const Contact = new Contact$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Occupancy$Type extends MessageType<Occupancy> {
    constructor() {
        super("aruba_telemetry.Occupancy", [
            { no: 1, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Occupancy>): Occupancy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Occupancy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Occupancy): Occupancy {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Occupancy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 level = 1; */
        if (message.level !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.level);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Occupancy
 */
export const Occupancy = new Occupancy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sensors$Type extends MessageType<Sensors> {
    constructor() {
        super("aruba_telemetry.Sensors", [
            { no: 1, name: "accelerometer", kind: "message", T: () => Accelerometer },
            { no: 2, name: "battery", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "temperatureC", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "humidity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "voltage", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "illumination", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "motion", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "current", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 9, name: "CO", kind: "scalar", jsonName: "CO", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "CO2", kind: "scalar", jsonName: "CO2", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "VOC", kind: "scalar", jsonName: "VOC", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "resistance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "pressure", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 14, name: "alarm", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["aruba_telemetry.Alarm", Alarm] },
            { no: 15, name: "contact", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Contact },
            { no: 16, name: "occupancy", kind: "message", T: () => Occupancy },
            { no: 17, name: "mechanicalHandle", kind: "enum", opt: true, T: () => ["aruba_telemetry.MechanicalH", MechanicalH] },
            { no: 18, name: "distance", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "capacitance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Sensors>): Sensors {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.alarm = [];
        message.contact = [];
        if (value !== undefined)
            reflectionMergePartial<Sensors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sensors): Sensors {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional aruba_telemetry.Accelerometer accelerometer */ 1:
                    message.accelerometer = Accelerometer.internalBinaryRead(reader, reader.uint32(), options, message.accelerometer);
                    break;
                case /* optional int32 battery */ 2:
                    message.battery = reader.int32();
                    break;
                case /* optional float temperatureC */ 3:
                    message.temperatureC = reader.float();
                    break;
                case /* optional int32 humidity */ 4:
                    message.humidity = reader.int32();
                    break;
                case /* optional float voltage */ 5:
                    message.voltage = reader.float();
                    break;
                case /* optional int32 illumination */ 6:
                    message.illumination = reader.int32();
                    break;
                case /* optional bool motion */ 7:
                    message.motion = reader.bool();
                    break;
                case /* optional sint32 current */ 8:
                    message.current = reader.sint32();
                    break;
                case /* optional int32 CO = 9 [json_name = "CO"];*/ 9:
                    message.cO = reader.int32();
                    break;
                case /* optional int32 CO2 = 10 [json_name = "CO2"];*/ 10:
                    message.cO2 = reader.int32();
                    break;
                case /* optional int32 VOC = 11 [json_name = "VOC"];*/ 11:
                    message.vOC = reader.int32();
                    break;
                case /* optional float resistance */ 12:
                    message.resistance = reader.float();
                    break;
                case /* optional sint32 pressure */ 13:
                    message.pressure = reader.sint32();
                    break;
                case /* repeated aruba_telemetry.Alarm alarm */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.alarm.push(reader.int32());
                    else
                        message.alarm.push(reader.int32());
                    break;
                case /* repeated aruba_telemetry.Contact contact */ 15:
                    message.contact.push(Contact.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional aruba_telemetry.Occupancy occupancy */ 16:
                    message.occupancy = Occupancy.internalBinaryRead(reader, reader.uint32(), options, message.occupancy);
                    break;
                case /* optional aruba_telemetry.MechanicalH mechanicalHandle */ 17:
                    message.mechanicalHandle = reader.int32();
                    break;
                case /* optional int32 distance */ 18:
                    message.distance = reader.int32();
                    break;
                case /* optional float capacitance */ 19:
                    message.capacitance = reader.float();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sensors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional aruba_telemetry.Accelerometer accelerometer = 1; */
        if (message.accelerometer)
            Accelerometer.internalBinaryWrite(message.accelerometer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 battery = 2; */
        if (message.battery !== undefined)
            writer.tag(2, WireType.Varint).int32(message.battery);
        /* optional float temperatureC = 3; */
        if (message.temperatureC !== undefined)
            writer.tag(3, WireType.Bit32).float(message.temperatureC);
        /* optional int32 humidity = 4; */
        if (message.humidity !== undefined)
            writer.tag(4, WireType.Varint).int32(message.humidity);
        /* optional float voltage = 5; */
        if (message.voltage !== undefined)
            writer.tag(5, WireType.Bit32).float(message.voltage);
        /* optional int32 illumination = 6; */
        if (message.illumination !== undefined)
            writer.tag(6, WireType.Varint).int32(message.illumination);
        /* optional bool motion = 7; */
        if (message.motion !== undefined)
            writer.tag(7, WireType.Varint).bool(message.motion);
        /* optional sint32 current = 8; */
        if (message.current !== undefined)
            writer.tag(8, WireType.Varint).sint32(message.current);
        /* optional int32 CO = 9 [json_name = "CO"]; */
        if (message.cO !== undefined)
            writer.tag(9, WireType.Varint).int32(message.cO);
        /* optional int32 CO2 = 10 [json_name = "CO2"]; */
        if (message.cO2 !== undefined)
            writer.tag(10, WireType.Varint).int32(message.cO2);
        /* optional int32 VOC = 11 [json_name = "VOC"]; */
        if (message.vOC !== undefined)
            writer.tag(11, WireType.Varint).int32(message.vOC);
        /* optional float resistance = 12; */
        if (message.resistance !== undefined)
            writer.tag(12, WireType.Bit32).float(message.resistance);
        /* optional sint32 pressure = 13; */
        if (message.pressure !== undefined)
            writer.tag(13, WireType.Varint).sint32(message.pressure);
        /* repeated aruba_telemetry.Alarm alarm = 14; */
        for (let i = 0; i < message.alarm.length; i++)
            writer.tag(14, WireType.Varint).int32(message.alarm[i]);
        /* repeated aruba_telemetry.Contact contact = 15; */
        for (let i = 0; i < message.contact.length; i++)
            Contact.internalBinaryWrite(message.contact[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.Occupancy occupancy = 16; */
        if (message.occupancy)
            Occupancy.internalBinaryWrite(message.occupancy, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.MechanicalH mechanicalHandle = 17; */
        if (message.mechanicalHandle !== undefined)
            writer.tag(17, WireType.Varint).int32(message.mechanicalHandle);
        /* optional int32 distance = 18; */
        if (message.distance !== undefined)
            writer.tag(18, WireType.Varint).int32(message.distance);
        /* optional float capacitance = 19; */
        if (message.capacitance !== undefined)
            writer.tag(19, WireType.Bit32).float(message.capacitance);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Sensors
 */
export const Sensors = new Sensors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Stats$Type extends MessageType<Stats> {
    constructor() {
        super("aruba_telemetry.Stats", [
            { no: 1, name: "uptime", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "adv_cnt", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "seq_nr", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "frame_cnt", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Stats>): Stats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frameCnt = 0;
        if (value !== undefined)
            reflectionMergePartial<Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stats): Stats {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 uptime */ 1:
                    message.uptime = reader.uint64().toString();
                    break;
                case /* optional uint64 adv_cnt */ 2:
                    message.advCnt = reader.uint64().toString();
                    break;
                case /* optional uint32 seq_nr */ 3:
                    message.seqNr = reader.uint32();
                    break;
                case /* uint32 frame_cnt */ 4:
                    message.frameCnt = reader.uint32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 uptime = 1; */
        if (message.uptime !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.uptime);
        /* optional uint64 adv_cnt = 2; */
        if (message.advCnt !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.advCnt);
        /* optional uint32 seq_nr = 3; */
        if (message.seqNr !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.seqNr);
        /* uint32 frame_cnt = 4; */
        if (message.frameCnt !== 0)
            writer.tag(4, WireType.Varint).uint32(message.frameCnt);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Stats
 */
export const Stats = new Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Inputs$Type extends MessageType<Inputs> {
    constructor() {
        super("aruba_telemetry.Inputs", [
            { no: 1, name: "rocker", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RockerSwitch },
            { no: 2, name: "switchIndex", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["aruba_telemetry.switchState", switchState] }
        ]);
    }
    create(value?: PartialMessage<Inputs>): Inputs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rocker = [];
        message.switchIndex = [];
        if (value !== undefined)
            reflectionMergePartial<Inputs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Inputs): Inputs {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated aruba_telemetry.RockerSwitch rocker */ 1:
                    message.rocker.push(RockerSwitch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated aruba_telemetry.switchState switchIndex */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.switchIndex.push(reader.int32());
                    else
                        message.switchIndex.push(reader.int32());
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Inputs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated aruba_telemetry.RockerSwitch rocker = 1; */
        for (let i = 0; i < message.rocker.length; i++)
            RockerSwitch.internalBinaryWrite(message.rocker[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated aruba_telemetry.switchState switchIndex = 2; */
        for (let i = 0; i < message.switchIndex.length; i++)
            writer.tag(2, WireType.Varint).int32(message.switchIndex[i]);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Inputs
 */
export const Inputs = new Inputs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VendorData$Type extends MessageType<VendorData> {
    constructor() {
        super("aruba_telemetry.VendorData", [
            { no: 1, name: "vendor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<VendorData>): VendorData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<VendorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VendorData): VendorData {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string vendor */ 1:
                    message.vendor = reader.string();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VendorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string vendor = 1; */
        if (message.vendor !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.vendor);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.VendorData
 */
export const VendorData = new VendorData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BTCompanyID$Type extends MessageType<BTCompanyID> {
    constructor() {
        super("aruba_telemetry.BTCompanyID", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BTCompanyID>): BTCompanyID {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BTCompanyID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BTCompanyID): BTCompanyID {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 value */ 1:
                    message.value = reader.uint32();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BTCompanyID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.value);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.BTCompanyID
 */
export const BTCompanyID = new BTCompanyID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reported$Type extends MessageType<Reported> {
    constructor() {
        super("aruba_telemetry.Reported", [
            { no: 1, name: "mac", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "deviceClass", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["aruba_telemetry.deviceClassEnum", deviceClassEnum] },
            { no: 3, name: "model", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "firmware", kind: "message", T: () => Firmware },
            { no: 5, name: "assetId", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "publicKey", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "lastSeen", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/ },
            { no: 9, name: "bevent", kind: "message", T: () => BeaconEvent },
            { no: 10, name: "rssi", kind: "message", T: () => Rssi },
            { no: 11, name: "cell", kind: "message", T: () => Cell },
            { no: 12, name: "beacons", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Beacons },
            { no: 13, name: "txpower", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 14, name: "sensors", kind: "message", T: () => Sensors },
            { no: 16, name: "stats", kind: "message", T: () => Stats },
            { no: 17, name: "inputs", kind: "message", T: () => Inputs },
            { no: 18, name: "vendorData", kind: "message", T: () => VendorData },
            { no: 19, name: "vendorName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "sensorTimestamp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/ },
            { no: 21, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "localName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "identity", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "companyIdentifier", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BTCompanyID }
        ]);
    }
    create(value?: PartialMessage<Reported>): Reported {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceClass = [];
        message.beacons = [];
        message.companyIdentifier = [];
        if (value !== undefined)
            reflectionMergePartial<Reported>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reported): Reported {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes mac */ 1:
                    message.mac = reader.bytes();
                    break;
                case /* repeated aruba_telemetry.deviceClassEnum deviceClass */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.deviceClass.push(reader.int32());
                    else
                        message.deviceClass.push(reader.int32());
                    break;
                case /* optional string model */ 3:
                    message.model = reader.string();
                    break;
                case /* optional aruba_telemetry.Firmware firmware */ 4:
                    message.firmware = Firmware.internalBinaryRead(reader, reader.uint32(), options, message.firmware);
                    break;
                case /* optional string assetId */ 5:
                    message.assetId = reader.string();
                    break;
                case /* optional bytes publicKey */ 6:
                    message.publicKey = reader.bytes();
                    break;
                case /* optional uint64 lastSeen */ 7:
                    message.lastSeen = reader.uint64().toString();
                    break;
                case /* optional aruba_telemetry.BeaconEvent bevent */ 9:
                    message.bevent = BeaconEvent.internalBinaryRead(reader, reader.uint32(), options, message.bevent);
                    break;
                case /* optional aruba_telemetry.Rssi rssi */ 10:
                    message.rssi = Rssi.internalBinaryRead(reader, reader.uint32(), options, message.rssi);
                    break;
                case /* optional aruba_telemetry.Cell cell */ 11:
                    message.cell = Cell.internalBinaryRead(reader, reader.uint32(), options, message.cell);
                    break;
                case /* repeated aruba_telemetry.Beacons beacons */ 12:
                    message.beacons.push(Beacons.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional sint32 txpower */ 13:
                    message.txpower = reader.sint32();
                    break;
                case /* optional aruba_telemetry.Sensors sensors */ 14:
                    message.sensors = Sensors.internalBinaryRead(reader, reader.uint32(), options, message.sensors);
                    break;
                case /* optional aruba_telemetry.Stats stats */ 16:
                    message.stats = Stats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* optional aruba_telemetry.Inputs inputs */ 17:
                    message.inputs = Inputs.internalBinaryRead(reader, reader.uint32(), options, message.inputs);
                    break;
                case /* optional aruba_telemetry.VendorData vendorData */ 18:
                    message.vendorData = VendorData.internalBinaryRead(reader, reader.uint32(), options, message.vendorData);
                    break;
                case /* optional string vendorName */ 19:
                    message.vendorName = reader.string();
                    break;
                case /* optional uint64 sensorTimestamp */ 20:
                    message.sensorTimestamp = reader.uint64().toString();
                    break;
                case /* optional uint32 flags */ 21:
                    message.flags = reader.uint32();
                    break;
                case /* optional string localName */ 22:
                    message.localName = reader.string();
                    break;
                case /* optional string identity */ 23:
                    message.identity = reader.string();
                    break;
                case /* repeated aruba_telemetry.BTCompanyID companyIdentifier */ 24:
                    message.companyIdentifier.push(BTCompanyID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reported, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes mac = 1; */
        if (message.mac !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.mac);
        /* repeated aruba_telemetry.deviceClassEnum deviceClass = 2; */
        for (let i = 0; i < message.deviceClass.length; i++)
            writer.tag(2, WireType.Varint).int32(message.deviceClass[i]);
        /* optional string model = 3; */
        if (message.model !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.model);
        /* optional aruba_telemetry.Firmware firmware = 4; */
        if (message.firmware)
            Firmware.internalBinaryWrite(message.firmware, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string assetId = 5; */
        if (message.assetId !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.assetId);
        /* optional bytes publicKey = 6; */
        if (message.publicKey !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.publicKey);
        /* optional uint64 lastSeen = 7; */
        if (message.lastSeen !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.lastSeen);
        /* optional aruba_telemetry.BeaconEvent bevent = 9; */
        if (message.bevent)
            BeaconEvent.internalBinaryWrite(message.bevent, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.Rssi rssi = 10; */
        if (message.rssi)
            Rssi.internalBinaryWrite(message.rssi, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.Cell cell = 11; */
        if (message.cell)
            Cell.internalBinaryWrite(message.cell, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated aruba_telemetry.Beacons beacons = 12; */
        for (let i = 0; i < message.beacons.length; i++)
            Beacons.internalBinaryWrite(message.beacons[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* optional sint32 txpower = 13; */
        if (message.txpower !== undefined)
            writer.tag(13, WireType.Varint).sint32(message.txpower);
        /* optional aruba_telemetry.Sensors sensors = 14; */
        if (message.sensors)
            Sensors.internalBinaryWrite(message.sensors, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.Stats stats = 16; */
        if (message.stats)
            Stats.internalBinaryWrite(message.stats, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.Inputs inputs = 17; */
        if (message.inputs)
            Inputs.internalBinaryWrite(message.inputs, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional aruba_telemetry.VendorData vendorData = 18; */
        if (message.vendorData)
            VendorData.internalBinaryWrite(message.vendorData, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional string vendorName = 19; */
        if (message.vendorName !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.vendorName);
        /* optional uint64 sensorTimestamp = 20; */
        if (message.sensorTimestamp !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.sensorTimestamp);
        /* optional uint32 flags = 21; */
        if (message.flags !== undefined)
            writer.tag(21, WireType.Varint).uint32(message.flags);
        /* optional string localName = 22; */
        if (message.localName !== undefined)
            writer.tag(22, WireType.LengthDelimited).string(message.localName);
        /* optional string identity = 23; */
        if (message.identity !== undefined)
            writer.tag(23, WireType.LengthDelimited).string(message.identity);
        /* repeated aruba_telemetry.BTCompanyID companyIdentifier = 24; */
        for (let i = 0; i < message.companyIdentifier.length; i++)
            BTCompanyID.internalBinaryWrite(message.companyIdentifier[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Reported
 */
export const Reported = new Reported$Type();
