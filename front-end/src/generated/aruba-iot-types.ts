/* eslint-disable no-case-declarations */
// @generated by protobuf-ts 2.9.3 with parameter long_type_string
// @generated from protobuf file "aruba-iot-types.proto" (package "aruba_telemetry", syntax proto2)
// tslint:disable
//
//  (C) Copyright [2018-2022] Hewlett Packard Enterprise Development LP
//  Note: File corresponds to AOS 8.10.x.x release
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * The topic includes the bonding key generated after sucessful pairing and bonding.
 * Bonding happens only when both sides enable bonding
 *
 * @generated from protobuf message aruba_telemetry.BleBondingKey
 */
export interface BleBondingKey {
    /**
     * Encryption key which is generated when bonding is enabled for pairing
     *
     * @generated from protobuf field: optional bytes key = 1;
     */
    key?: Uint8Array;
}
/**
 * Mandatory header for every frame
 *
 * @generated from protobuf message aruba_telemetry.Meta
 */
export interface Meta {
    /**
     * Only version 1 is supported for now
     *
     * @generated from protobuf field: uint64 version = 1;
     */
    version: string;
    /**
     * Access Token is provided in all NB frames. The server is expected to validate the
     * token and report an error if the token is not valid
     *
     * @generated from protobuf field: optional string access_token = 2;
     */
    accessToken?: string;
    /**
     * For Northbound frames, the topic indicates the type of payload.
     * Only one topic can be present per message
     *
     * @generated from protobuf field: optional aruba_telemetry.NbTopic nbTopic = 3;
     */
    nbTopic?: NbTopic;
    /**
     * For SouthBound frames, the topic indicates the type of payload.
     * Only one topic can be present per message
     *
     * @generated from protobuf field: optional aruba_telemetry.SbTopic sbTopic = 4;
     */
    sbTopic?: SbTopic;
}
/**
 * enumeration of device classes. These device classes
 * can be used to filter devices and will be used to classify each device.
 * An IOT device can be part of more than one class.
 *
 * @generated from protobuf enum aruba_telemetry.deviceClassEnum
 */
export enum deviceClassEnum {
    /**
     * @generated from protobuf enum value: unclassified = 0;
     */
    unclassified = 0,
    /**
     * @generated from protobuf enum value: arubaBeacon = 1;
     */
    arubaBeacon = 1,
    /**
     * @generated from protobuf enum value: arubaTag = 2;
     */
    arubaTag = 2,
    /**
     * @generated from protobuf enum value: zfTag = 3;
     */
    zfTag = 3,
    /**
     * @generated from protobuf enum value: stanleyTag = 4;
     */
    stanleyTag = 4,
    /**
     * @generated from protobuf enum value: virginBeacon = 5;
     */
    virginBeacon = 5,
    /**
     * @generated from protobuf enum value: enoceanSensor = 6;
     */
    enoceanSensor = 6,
    /**
     * @generated from protobuf enum value: enoceanSwitch = 7;
     */
    enoceanSwitch = 7,
    /**
     * @generated from protobuf enum value: iBeacon = 8;
     */
    iBeacon = 8,
    /**
     * @generated from protobuf enum value: allBleData = 9;
     */
    allBleData = 9,
    /**
     * @generated from protobuf enum value: RawBleData = 10;
     */
    RawBleData = 10,
    /**
     * @generated from protobuf enum value: eddystone = 11;
     */
    eddystone = 11,
    /**
     * @generated from protobuf enum value: assaAbloy = 12;
     */
    assaAbloy = 12,
    /**
     * @generated from protobuf enum value: arubaSensor = 13;
     */
    arubaSensor = 13,
    /**
     * @generated from protobuf enum value: abbSensor = 14;
     */
    abbSensor = 14,
    /**
     * @generated from protobuf enum value: wifiTag = 15;
     */
    wifiTag = 15,
    /**
     * @generated from protobuf enum value: wifiAssocSta = 16;
     */
    wifiAssocSta = 16,
    /**
     * @generated from protobuf enum value: wifiUnassocSta = 17;
     */
    wifiUnassocSta = 17,
    /**
     * @generated from protobuf enum value: mysphera = 18;
     */
    mysphera = 18,
    /**
     * @generated from protobuf enum value: sBeacon = 19;
     */
    sBeacon = 19,
    /**
     * @generated from protobuf enum value: wiliot = 20;
     */
    wiliot = 20,
    /**
     * @generated from protobuf enum value: ZSD = 21;
     */
    ZSD = 21,
    /**
     * @generated from protobuf enum value: serialdata = 22;
     */
    serialdata = 22,
    /**
     * @generated from protobuf enum value: exposureNotification = 23;
     */
    exposureNotification = 23,
    /**
     * @generated from protobuf enum value: onity = 24;
     */
    onity = 24,
    /**
     * @generated from protobuf enum value: minew = 25;
     */
    minew = 25,
    /**
     * @generated from protobuf enum value: google = 26;
     */
    google = 26,
    /**
     * @generated from protobuf enum value: polestar = 27;
     */
    polestar = 27,
    /**
     * @generated from protobuf enum value: blyott = 28;
     */
    blyott = 28,
    /**
     * @generated from protobuf enum value: diract = 29;
     */
    diract = 29,
    /**
     * @generated from protobuf enum value: gwahygiene = 30;
     */
    gwahygiene = 30,
    /**
     * @generated from protobuf enum value: noneBleData = 31;
     */
    noneBleData = 31
}
/**
 * Actions used in the southbound API.
 *
 * @generated from protobuf enum aruba_telemetry.ActionType
 */
export enum ActionType {
    /**
     * Connect to a BLE device
     *
     * @generated from protobuf enum value: bleConnect = 0;
     */
    bleConnect = 0,
    /**
     * Disconnect from a BLE device
     * The device must already be connnected for this action to succeed
     *
     * @generated from protobuf enum value: bleDisconnect = 1;
     */
    bleDisconnect = 1,
    /**
     * Read from GATT characteristic. The value will be returned using the 'characteristics' topic.
     * The action result will be returned in the 'results' topic
     * The device must already be connnected for this action to succeed
     *
     * @generated from protobuf enum value: gattRead = 2;
     */
    gattRead = 2,
    /**
     * Write to GATT characteristic.
     * The action result will be returned in the 'results' topic
     * The device must already be connnected for this action to succeed
     *
     * @generated from protobuf enum value: gattWrite = 3;
     */
    gattWrite = 3,
    /**
     * @generated from protobuf enum value: gattWriteWithResponse = 4;
     */
    gattWriteWithResponse = 4,
    /**
     * Enable/Disable GATT notifications on a characteristic.
     * Notifications will result in updated values via the 'characteristcs' topic.
     * The device must already be connnected for this action to succeed
     *
     * @generated from protobuf enum value: gattNotification = 5;
     */
    gattNotification = 5,
    /**
     * Enable/Disable GATT indications on a characteristic.
     * Indications will result in updated values via the 'characteristics' topic.
     * The device must already be connnected for this action to succeed
     *
     * @generated from protobuf enum value: gattIndication = 6;
     */
    gattIndication = 6,
    /**
     * Authenticate peer BLE device, which is an optional action.
     * This action can only be used during connection
     *
     * @generated from protobuf enum value: bleAuthenticate = 7;
     */
    bleAuthenticate = 7,
    /**
     * Encrypt link with the key received from last successful authentication.
     * Also, this action can only be used during connection
     *
     * @generated from protobuf enum value: bleEncrypt = 8;
     */
    bleEncrypt = 8
}
/**
 * The topic helps in identifying the message type
 * NbTopic specifies the topic for Northbound messages
 *
 * @generated from protobuf enum aruba_telemetry.NbTopic
 */
export enum NbTopic {
    /**
     * @generated from protobuf enum value: telemetry = 0;
     */
    telemetry = 0,
    /**
     * @generated from protobuf enum value: actionResults = 1;
     */
    actionResults = 1,
    /**
     * @generated from protobuf enum value: characteristics = 2;
     */
    characteristics = 2,
    /**
     * @generated from protobuf enum value: bleData = 3;
     */
    bleData = 3,
    /**
     * @generated from protobuf enum value: wifiData = 4;
     */
    wifiData = 4,
    /**
     * @generated from protobuf enum value: deviceCount = 5;
     */
    deviceCount = 5,
    /**
     * @generated from protobuf enum value: status = 6;
     */
    status = 6,
    /**
     * @generated from protobuf enum value: zbNbData = 7;
     */
    zbNbData = 7,
    /**
     * @generated from protobuf enum value: serialDataNb = 8;
     */
    serialDataNb = 8,
    /**
     * @generated from protobuf enum value: apHealthUpdate = 9;
     */
    apHealthUpdate = 9
}
/**
 * The topic helps in identifying the message type
 * SbTopic specifies the topic for Southbound messages
 *
 * @generated from protobuf enum aruba_telemetry.SbTopic
 */
export enum SbTopic {
    /**
     * @generated from protobuf enum value: actions = 0;
     */
    actions = 0,
    /**
     * @generated from protobuf enum value: config = 1;
     */
    config = 1,
    /**
     * @generated from protobuf enum value: sbStatus = 2;
     */
    sbStatus = 2,
    /**
     * @generated from protobuf enum value: zbSbData = 3;
     */
    zbSbData = 3,
    /**
     * @generated from protobuf enum value: serialDataSb = 4;
     */
    serialDataSb = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class BleBondingKey$Type extends MessageType<BleBondingKey> {
    constructor() {
        super("aruba_telemetry.BleBondingKey", [
            { no: 1, name: "key", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<BleBondingKey>): BleBondingKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BleBondingKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BleBondingKey): BleBondingKey {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BleBondingKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes key = 1; */
        if (message.key !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.BleBondingKey
 */
export const BleBondingKey = new BleBondingKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Meta$Type extends MessageType<Meta> {
    constructor() {
        super("aruba_telemetry.Meta", [
            { no: 1, name: "version", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "access_token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nbTopic", kind: "enum", opt: true, T: () => ["aruba_telemetry.NbTopic", NbTopic] },
            { no: 4, name: "sbTopic", kind: "enum", opt: true, T: () => ["aruba_telemetry.SbTopic", SbTopic] }
        ]);
    }
    create(value?: PartialMessage<Meta>): Meta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "0";
        if (value !== undefined)
            reflectionMergePartial<Meta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Meta): Meta {
        const message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 version */ 1:
                    message.version = reader.uint64().toString();
                    break;
                case /* optional string access_token */ 2:
                    message.accessToken = reader.string();
                    break;
                case /* optional aruba_telemetry.NbTopic nbTopic */ 3:
                    message.nbTopic = reader.int32();
                    break;
                case /* optional aruba_telemetry.SbTopic sbTopic */ 4:
                    message.sbTopic = reader.int32();
                    break;
                default:
                    const u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    const d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Meta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 version = 1; */
        if (message.version !== "0")
            writer.tag(1, WireType.Varint).uint64(message.version);
        /* optional string access_token = 2; */
        if (message.accessToken !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.accessToken);
        /* optional aruba_telemetry.NbTopic nbTopic = 3; */
        if (message.nbTopic !== undefined)
            writer.tag(3, WireType.Varint).int32(message.nbTopic);
        /* optional aruba_telemetry.SbTopic sbTopic = 4; */
        if (message.sbTopic !== undefined)
            writer.tag(4, WireType.Varint).int32(message.sbTopic);
        const u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message aruba_telemetry.Meta
 */
export const Meta = new Meta$Type();
